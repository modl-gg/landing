import { InsertServer, Server } from "modl-shared-web";
import { MongoClient } from "mongodb";
import 'dotenv/config';

// modify the interface with any CRUD methods
// you might need

export interface IStorage {
  // getUser(id: number): Promise<User | undefined>; // Removed
  // getUserByUsername(username: string): Promise<User | undefined>; // Removed
  // createUser(user: InsertUser): Promise<User>; // Removed
  createServer(serverData: InsertServer): Promise<Server>;
}

export class MemStorage implements IStorage {
  // private users: Map<number, User>; // Removed
  private servers: Map<string, Server>; // Changed to string for ObjectId
  // currentId: number; // Removed
  // currentServerId: number; // No longer needed as MongoDB handles ID
  private mongoClient: MongoClient;
  private readonly mongoDbName = "modl";

  constructor() {
    // this.users = new Map(); // Removed
    this.servers = new Map();
    // this.currentId = 1; // Removed
    // this.currentServerId = 1;
    // Replace with your MongoDB connection string
    const uri = process.env.MONGODB_URI || "mongodb://localhost:27017";
    this.mongoClient = new MongoClient(uri, {
      maxPoolSize: 50, // Maintain up to 50 socket connections
      serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
      socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
      connectTimeoutMS: 10000 // Give up initial connection after 10 seconds
    });
    this.connectMongo();
  }

  private async connectMongo() {
    try {
      await this.mongoClient.connect();
      console.log("Connected to MongoDB");
    } catch (error) {
      console.error("Failed to connect to MongoDB", error);
      // Throw an error to prevent application startup if database is critical
      throw new Error(`MongoDB Connection Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // async getUser(id: number): Promise<User | undefined> { // Removed
  //   return this.users.get(id);
  // }

  // async getUserByUsername(username: string): Promise<User | undefined> { // Removed
  //   return Array.from(this.users.values()).find(
  //     (user) => user.username === username,
  //   );
  // }

  // async createUser(insertUser: InsertUser): Promise<User> { // Removed
  //   const id = this.currentId++;
  //   const user: User = { ...insertUser, id };
  //   this.users.set(id, user);
  //   return user;
  // }

  async createServer(serverData: InsertServer): Promise<Server> {
    const db = this.mongoClient.db(this.mongoDbName);
    const serversCollection = db.collection("servers");

    // Check for duplicate entries
    const existingServer = await serversCollection.findOne({
      $or: [
        { adminEmail: serverData.adminEmail },
        { serverName: serverData.serverName },
        { customDomain: serverData.customDomain },
      ],
    });

    if (existingServer) {
      if (existingServer.adminEmail === serverData.adminEmail) {
        throw new Error("DUPLICATE_ENTRY: An account with this email already exists.");
      }
      if (existingServer.serverName === serverData.serverName) {
        throw new Error("DUPLICATE_ENTRY: This server name is already taken.");
      }
      if (existingServer.customDomain === serverData.customDomain) {
        throw new Error("DUPLICATE_ENTRY: This subdomain is already in use.");
      }
      // Fallback for an unexpected match
      throw new Error("DUPLICATE_ENTRY: A similar server configuration already exists.");
    }

    const newServerDocument = {
      ...serverData,
      // _id is now generated by MongoDB
    };

    const result = await serversCollection.insertOne(newServerDocument);
    const insertedId = result.insertedId; // Get the ObjectId generated by MongoDB

    const server: Server = {
      id: insertedId.toHexString(),
      ...serverData
    };
    // this.servers.set(insertedId.toHexString(), server); // Also keep in-memory if needed, or rely solely on MongoDB
    return server;
  }
}

export const storage = new MemStorage();
